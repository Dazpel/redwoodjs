'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var nodeRequestInterceptor = require('node-request-interceptor');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var Headers_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var HEADERS_INVALID_CHARACTERS = /[^a-z0-9\-#$%&'*+.^_`|~]/i;
var Headers = /** @class */ (function () {
    function Headers(headers) {
        var _this = this;
        this.map = {};
        if ((headers === null || headers === void 0 ? void 0 : headers.constructor.name) === 'Headers') {
            headers.forEach(function (value, name) {
                _this.append(name, value);
            }, this);
        }
        else if (Array.isArray(headers)) {
            headers.forEach(function (_a) {
                var name = _a[0], value = _a[1];
                _this.append(name, Array.isArray(value) ? value.join(', ') : value);
            });
        }
        else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function (name) {
                _this.append(name, headers[name]);
            });
        }
    }
    /**
     * Sets a new value for an existing header inside a `Headers` object, or adds the header if it does not already exist.
     */
    Headers.prototype.set = function (name, value) {
        this.map[this.normalizeName(name)] = this.normalizeValue(value);
    };
    /**
     * Appends a new value onto an existing header inside a `Headers` object, or adds the header if it does not already exist.
     */
    Headers.prototype.append = function (name, value) {
        name = this.normalizeName(name);
        value = this.normalizeValue(value);
        this.map[name] = this.has(name) ? this.map[name] + ", " + value : value;
    };
    /**
     * Deletes a header from the `Headers` object.
     */
    Headers.prototype.delete = function (name) {
        delete this.map[this.normalizeName(name)];
        return this;
    };
    /**
     * Returns a `ByteString` sequence of all the values of a header with a given name.
     */
    Headers.prototype.get = function (name) {
        return this.map[this.normalizeName(name)] || null;
    };
    /**
     * Returns the map of all headers in a `Headers` object.
     */
    Headers.prototype.getAllHeaders = function () {
        return this.map;
    };
    /**
     * Returns a boolean stating whether a `Headers` object contains a certain header.
     */
    Headers.prototype.has = function (name) {
        return this.map.hasOwnProperty(this.normalizeName(name));
    };
    Headers.prototype.forEach = function (callback, thisArg) {
        for (var name_1 in this.map) {
            if (this.map.hasOwnProperty(name_1)) {
                callback.call(thisArg, this.map[name_1], name_1, this);
            }
        }
    };
    Headers.prototype.normalizeName = function (name) {
        if (typeof name !== 'string') {
            name = String(name);
        }
        if (HEADERS_INVALID_CHARACTERS.test(name) || name.trim() === '') {
            throw new TypeError('Invalid character in header field name');
        }
        return name.toLowerCase();
    };
    Headers.prototype.normalizeValue = function (value) {
        if (typeof value !== 'string') {
            value = String(value);
        }
        return value;
    };
    return Headers;
}());
exports.Headers = Headers;
});

unwrapExports(Headers_1);
var Headers_2 = Headers_1.Headers;

var headersToList_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
function headersToList(headers) {
    var headersList = [];
    headers.forEach(function (value, name) {
        var resolvedValue = value.includes(',')
            ? value.split(',').map(function (v) { return v.trim(); })
            : value;
        headersList.push([name, resolvedValue]);
    });
    return headersList;
}
exports.headersToList = headersToList;
});

unwrapExports(headersToList_1);
var headersToList_2 = headersToList_1.headersToList;

var headersToObject_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
// List of headers that cannot have multiple values,
// while potentially having a comma in their single value.
var singleValueHeaders = ['user-agent'];
/**
 * Converts a given `Headers` instance into a plain object.
 * Respects headers with multiple values.
 */
function headersToObject(headers) {
    var headersObject = {};
    headers.forEach(function (value, name) {
        var isMultiValue = !singleValueHeaders.includes(name.toLowerCase()) && value.includes(',');
        headersObject[name] = isMultiValue
            ? value.split(',').map(function (s) { return s.trim(); })
            : value;
    });
    return headersObject;
}
exports.headersToObject = headersToObject;
});

unwrapExports(headersToObject_1);
var headersToObject_2 = headersToObject_1.headersToObject;

var stringToHeaders_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Converts a string representation of headers (i.e. from XMLHttpRequest)
 * to a `Headers` instance.
 */
function stringToHeaders(str) {
    var lines = str.trim().split(/[\r\n]+/);
    return lines.reduce(function (headers, line) {
        var parts = line.split(': ');
        var name = parts.shift();
        var value = parts.join(': ');
        headers.append(name, value);
        return headers;
    }, new Headers());
}
exports.stringToHeaders = stringToHeaders;
});

unwrapExports(stringToHeaders_1);
var stringToHeaders_2 = stringToHeaders_1.stringToHeaders;

var listToHeaders_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
function listToHeaders(list) {
    var headers = new Headers();
    list.forEach(function (_a) {
        var name = _a[0], value = _a[1];
        var values = [].concat(value);
        values.forEach(function (value) {
            headers.append(name, value);
        });
    });
    return headers;
}
exports.listToHeaders = listToHeaders;
});

unwrapExports(listToHeaders_1);
var listToHeaders_2 = listToHeaders_1.listToHeaders;

var objectToHeaders_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
function objectToHeaders(obj) {
    var headers = new Headers();
    Object.keys(obj).forEach(function (name) {
        var values = [].concat(obj[name]);
        values.forEach(function (value) {
            headers.append(name, value);
        });
    });
    return headers;
}
exports.objectToHeaders = objectToHeaders;
});

unwrapExports(objectToHeaders_1);
var objectToHeaders_2 = objectToHeaders_1.objectToHeaders;

var flattenHeadersList_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
function flattenHeadersList(list) {
    return list.map(function (_a) {
        var name = _a[0], values = _a[1];
        return [name, [].concat(values).join('; ')];
    });
}
exports.flattenHeadersList = flattenHeadersList;
});

unwrapExports(flattenHeadersList_1);
var flattenHeadersList_2 = flattenHeadersList_1.flattenHeadersList;

var flattenHeadersObject_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
function flattenHeadersObject(obj) {
    return Object.keys(obj).reduce(function (acc, name) {
        acc[name] = [].concat(obj[name]).join('; ');
        return acc;
    }, {});
}
exports.flattenHeadersObject = flattenHeadersObject;
});

unwrapExports(flattenHeadersObject_1);
var flattenHeadersObject_2 = flattenHeadersObject_1.flattenHeadersObject;

var lib = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

exports.Headers = Headers_1.Headers;

exports.headersToList = headersToList_1.headersToList;

exports.headersToObject = headersToObject_1.headersToObject;

exports.stringToHeaders = stringToHeaders_1.stringToHeaders;

exports.listToHeaders = listToHeaders_1.listToHeaders;

exports.objectToHeaders = objectToHeaders_1.objectToHeaders;

exports.flattenHeadersList = flattenHeadersList_1.flattenHeadersList;

exports.flattenHeadersObject = flattenHeadersObject_1.flattenHeadersObject;
});

unwrapExports(lib);
var lib_1 = lib.Headers;
var lib_2 = lib.headersToList;
var lib_3 = lib.headersToObject;
var lib_4 = lib.stringToHeaders;
var lib_5 = lib.listToHeaders;
var lib_6 = lib.objectToHeaders;
var lib_7 = lib.flattenHeadersList;
var lib_8 = lib.flattenHeadersObject;

var statuses = {
	"100": "Continue",
	"101": "Switching Protocols",
	"102": "Processing",
	"103": "Early Hints",
	"200": "OK",
	"201": "Created",
	"202": "Accepted",
	"203": "Non-Authoritative Information",
	"204": "No Content",
	"205": "Reset Content",
	"206": "Partial Content",
	"207": "Multi-Status",
	"208": "Already Reported",
	"226": "IM Used",
	"300": "Multiple Choices",
	"301": "Moved Permanently",
	"302": "Found",
	"303": "See Other",
	"304": "Not Modified",
	"305": "Use Proxy",
	"307": "Temporary Redirect",
	"308": "Permanent Redirect",
	"400": "Bad Request",
	"401": "Unauthorized",
	"402": "Payment Required",
	"403": "Forbidden",
	"404": "Not Found",
	"405": "Method Not Allowed",
	"406": "Not Acceptable",
	"407": "Proxy Authentication Required",
	"408": "Request Timeout",
	"409": "Conflict",
	"410": "Gone",
	"411": "Length Required",
	"412": "Precondition Failed",
	"413": "Payload Too Large",
	"414": "URI Too Long",
	"415": "Unsupported Media Type",
	"416": "Range Not Satisfiable",
	"417": "Expectation Failed",
	"418": "I'm a Teapot",
	"421": "Misdirected Request",
	"422": "Unprocessable Entity",
	"423": "Locked",
	"424": "Failed Dependency",
	"425": "Too Early",
	"426": "Upgrade Required",
	"428": "Precondition Required",
	"429": "Too Many Requests",
	"431": "Request Header Fields Too Large",
	"451": "Unavailable For Legal Reasons",
	"500": "Internal Server Error",
	"501": "Not Implemented",
	"502": "Bad Gateway",
	"503": "Service Unavailable",
	"504": "Gateway Timeout",
	"505": "HTTP Version Not Supported",
	"506": "Variant Also Negotiates",
	"507": "Insufficient Storage",
	"508": "Loop Detected",
	"509": "Bandwidth Limit Exceeded",
	"510": "Not Extended",
	"511": "Network Authentication Required"
};

const status = (statusCode, statusText) => {
    return (res) => {
        res.status = statusCode;
        res.statusText =
            statusText || statuses[String(statusCode)];
        return res;
    };
};

function set(...args) {
    return (res) => {
        const [name, value] = args;
        if (typeof name === 'string') {
            res.headers.append(name, value);
        }
        else {
            const headers = lib_6(name);
            headers.forEach((value, name) => {
                res.headers.append(name, value);
            });
        }
        return res;
    };
}

const MIN_SERVER_RESPONSE_TIME = 100;
const MAX_SERVER_RESPONSE_TIME = 400;
const getRandomServerResponseTime = () => Math.floor(Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) +
    MIN_SERVER_RESPONSE_TIME);
/**
 * Delays the current response for the given duration (in ms)
 * @example
 * res(delay(1500), json({ foo: 'bar' }))
 */
const delay = (durationMs) => {
    return (res) => {
        res.delay = durationMs !== null && durationMs !== void 0 ? durationMs : getRandomServerResponseTime();
        return res;
    };
};

const gracefully = (promise) => {
    return promise.then((res) => {
        var _a;
        if ((_a = res.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('json')) {
            return res.json();
        }
        return res.text();
    });
};
const augmentRequestInit = (requestInit) => {
    const headers = new lib_1(requestInit.headers);
    headers.set('x-msw-bypass', 'true');
    return Object.assign(Object.assign({}, requestInit), { headers: headers.getAllHeaders() });
};
/**
 * Wrapper around the native `window.fetch()` function that performs
 * a request bypassing MSW. Requests performed using
 * this function will never be mocked.
 */
const fetch = (input, requestInit = {}) => {
    // Keep the default `window.fetch()` call signature
    if (typeof input === 'string') {
        return gracefully(window.fetch(input, augmentRequestInit(requestInit)));
    }
    const { body } = input;
    const compliantReq = augmentRequestInit(Object.assign(Object.assign({}, input), { body: typeof body === 'object' ? JSON.stringify(body) : body }));
    return gracefully(window.fetch(input.url.href, compliantReq));
};

const defaultContext = {
    status,
    set,
    delay,
    fetch,
};

function pipe(...funcs) {
    return funcs.reduce((f, g) => (...args) => f(g(...args)));
}

const defaultResponse = {
    status: 200,
    statusText: 'OK',
    body: null,
    delay: 0,
    once: false,
};
function createResponseComposition(overrides = {}) {
    return (...transformers) => {
        const resolvedResponse = Object.assign({}, defaultResponse, {
            headers: new lib_1({
                'x-powered-by': 'msw',
            }),
        }, overrides);
        if (transformers.length > 0) {
            return pipe(...transformers)(resolvedResponse);
        }
        return resolvedResponse;
    };
}
const response = Object.assign(createResponseComposition(), {
    once: createResponseComposition({ once: true }),
});

/**
 * Returns a mocked response for a given request using following request handlers.
 */
const getResponse = (req, handlers) => __awaiter(void 0, void 0, void 0, function* () {
    const [relevantHandler, parsedRequest] = handlers.reduce((found, requestHandler) => {
        // Skip any request handlers lookup if a handler is already found,
        // or the current handler is a one-time handler that's been already used.
        if ((found && found[0]) || requestHandler.shouldSkip) {
            return found;
        }
        // Parse the captured request to get additional information.
        // Make the predicate function accept all the necessary information
        // to decide on the interception.
        const parsedRequest = requestHandler.parse
            ? requestHandler.parse(req)
            : null;
        if (requestHandler.predicate(req, parsedRequest)) {
            return [requestHandler, parsedRequest];
        }
    }, []) || [null, null];
    if (relevantHandler == null) {
        return {
            handler: null,
            response: null,
        };
    }
    const { getPublicRequest, defineContext, resolver } = relevantHandler;
    const publicRequest = getPublicRequest
        ? getPublicRequest(req, parsedRequest)
        : req;
    const context = defineContext ? defineContext(publicRequest) : defaultContext;
    const mockedResponse = yield resolver(publicRequest, response, context);
    // Handle a scenario when a request handler is present,
    // but returns no mocked response (i.e. misses a `return res()` statement).
    if (!mockedResponse) {
        return {
            handler: relevantHandler,
            response: null,
        };
    }
    if (mockedResponse.once) {
        // When responded with a one-time response, match the relevant request handler
        // as skipped, so it cannot affect the captured requests anymore.
        relevantHandler.shouldSkip = true;
    }
    return {
        handler: relevantHandler,
        response: mockedResponse,
        publicRequest,
        parsedRequest,
    };
});

/**
 * Returns a parsed object from a given valid JSON string,
 * otherwise returns as text without parsing.
 */
function getJsonBody(body) {
    try {
        return JSON.parse(body);
    }
    catch (error) {
        return body;
    }
}

function parseRequestBody(body, headers) {
    var _a;
    if (body) {
        // If the intercepted request's body has a JSON Content-Type
        // parse it into an object, otherwise leave as-is.
        const isJsonBody = (_a = headers === null || headers === void 0 ? void 0 : headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('json');
        return isJsonBody && typeof body !== 'object' ? getJsonBody(body) : body;
    }
    // Return whatever falsey body value is given.
    return body;
}

function use(currentHandlers, ...handlers) {
    currentHandlers.unshift(...handlers);
}
function restoreHandlers(handlers) {
    handlers.forEach((handler) => {
        if ('shouldSkip' in handler) {
            handler.shouldSkip = false;
        }
    });
}
function resetHandlers(initialHandlers, ...nextHandlers) {
    return nextHandlers.length > 0 ? [...nextHandlers] : [...initialHandlers];
}

/**
 * Sets up a server-side requests interception with the given mock definition.
 */
const setupServer = (...requestHandlers) => {
    const interceptor = new nodeRequestInterceptor.RequestInterceptor();
    // Store the list of request handlers for the current server instance,
    // so it could be modified at a runtime.
    let currentHandlers = [...requestHandlers];
    return {
        /**
         * Enables requests interception based on the previously provided mock definition.
         */
        listen() {
            interceptor.use((req) => __awaiter(this, void 0, void 0, function* () {
                const requestHeaders = new lib_1(lib_8(req.headers || {}));
                const mockedRequest = {
                    url: req.url,
                    method: req.method,
                    // Parse the request's body based on the "Content-Type" header.
                    body: parseRequestBody(req.body, requestHeaders),
                    headers: requestHeaders,
                    params: {},
                    redirect: 'manual',
                    referrer: '',
                    keepalive: false,
                    cache: 'default',
                    mode: 'cors',
                    referrerPolicy: 'no-referrer',
                    integrity: '',
                    destination: 'document',
                    bodyUsed: false,
                    credentials: 'same-origin',
                };
                const { response } = yield getResponse(mockedRequest, currentHandlers);
                if (!response) {
                    // Return nothing, if no mocked response associated with this request.
                    // That makes `node-request-interceptor` to perform the request as-is.
                    return;
                }
                return new Promise((resolve) => {
                    setTimeout(() => {
                        resolve({
                            status: response.status,
                            statusText: response.statusText,
                            headers: response.headers.getAllHeaders(),
                            body: response.body,
                        });
                    }, response.delay);
                });
            }));
        },
        /**
         * Prepends given request handlers to the list of existing handlers.
         */
        use(...handlers) {
            use(currentHandlers, ...handlers);
        },
        /**
         * Marks all request handlers that respond using `res.once()` as unused.
         */
        restoreHandlers() {
            restoreHandlers(currentHandlers);
        },
        /**
         * Resets request handlers to the initial list given to the `setupServer` call, or to the explicit next request handlers list, if given.
         */
        resetHandlers(...nextHandlers) {
            currentHandlers = resetHandlers(requestHandlers, ...nextHandlers);
        },
        /**
         * Stops requests interception by restoring all augmented modules.
         */
        close() {
            interceptor.restore();
        },
    };
};

exports.setupServer = setupServer;

import { c as createCommonjsModule, u as unwrapExports, s as status, a as set, d as delay, f as fetch, l as lib_1$1, b as lib_2 } from './fetch-deps.js';
import './xml-deps.js';
import './errors-deps.js';
export { i as context } from './index-deps.js';
import { g as getJsonBody } from './styleStatusCode-deps.js';
import { i as isStringEqual } from './rest-deps.js';
export { R as RESTMethods, r as rest, a as restContext } from './rest-deps.js';
export { graphql, graphqlContext } from './graphql.js';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

var until = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Gracefully handles a given Promise factory.
 * @example
 * cosnt [error, data] = await until(() => asyncAction())
 */
exports.until = async (promise) => {
    try {
        const data = await promise().catch((error) => {
            throw error;
        });
        return [null, data];
    }
    catch (error) {
        return [error, null];
    }
};
});

unwrapExports(until);
var until_1 = until.until;

var lib = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

exports.until = until.until;
});

unwrapExports(lib);
var lib_1 = lib.until;

/**
 * Attempts to resolve a Service Worker instance from any of its states:
 * active, installing, or waiting.
 */
const getWorkerByRegistration = (registration) => {
    return registration.active || registration.installing || registration.waiting;
};

/**
 * Returns an absolute Service Worker URL based on the given
 * relative URL (known during the registration).
 */
function getAbsoluteWorkerUrl(relativeUrl) {
    return new URL(relativeUrl, location.origin).href;
}

/**
 * Returns an active Service Worker instance.
 * When not found, registers a new Service Worker.
 */
const getWorkerInstance = (url, options) => __awaiter(void 0, void 0, void 0, function* () {
    // Resolve the absolute Service Worker URL
    const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);
    const [, mockRegistrations] = yield lib_1(() => __awaiter(void 0, void 0, void 0, function* () {
        const registrations = yield navigator.serviceWorker.getRegistrations();
        return registrations.filter((registration) => {
            const worker = getWorkerByRegistration(registration);
            // Filter out other workers that can be associated with this page
            return (worker === null || worker === void 0 ? void 0 : worker.scriptURL) === absoluteWorkerUrl;
        });
    }));
    if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {
        // Reload the page when it has associated workers, but no active controller.
        // The absence of a controller can mean either:
        // - page has no Service Worker associated with it
        // - page has been hard-reloaded and its workers won't be used until the next reload.
        // Since we've checked that there are registrations associated with this page,
        // at this point we are sure it's hard reload that falls into this clause.
        location.reload();
    }
    const [, existingRegistration] = yield lib_1(() => {
        return navigator.serviceWorker.getRegistration(url);
    });
    if (existingRegistration) {
        // Update existing service worker to ensure it's up-to-date
        return existingRegistration.update().then(() => {
            return [
                getWorkerByRegistration(existingRegistration),
                existingRegistration,
            ];
        });
    }
    const [error, instance] = yield lib_1(() => __awaiter(void 0, void 0, void 0, function* () {
        const registration = yield navigator.serviceWorker.register(url, options);
        return [getWorkerByRegistration(registration), registration];
    }));
    if (error) {
        console.error('[MSW] Failed to register Service Worker (%s). %o', url, error);
        return null;
    }
    return instance;
});

/**
 * Creates a communication channel between the client
 * and the Service Worker associated with the given event.
 */
const createBroadcastChannel = (event) => {
    const port = event.ports[0];
    return {
        /**
         * Sends a text message to the connected Service Worker.
         */
        send(message) {
            if (port) {
                port.postMessage(JSON.stringify(message));
            }
        },
    };
};
const addMessageListener = (type, handler, errorHandler) => {
    const handleMessage = (event) => {
        const message = JSON.parse(event.data);
        if (message.type === type) {
            handler(message, event);
        }
    };
    navigator.serviceWorker.addEventListener('message', handleMessage);
    if (errorHandler) {
        navigator.serviceWorker.addEventListener('messageerror', errorHandler);
    }
    // Clean up the listener when page unloads
    window.addEventListener('beforeunload', () => {
        navigator.serviceWorker.removeEventListener('message', handleMessage);
        if (errorHandler) {
            navigator.serviceWorker.removeEventListener('messageerror', errorHandler);
        }
    });
};

const activateMocking = (worker, options) => {
    worker.postMessage('MOCK_ACTIVATE');
    return new Promise((resolve, reject) => {
        // Wait until the mocking is enabled to resolve the start Promise
        addMessageListener('MOCKING_ENABLED', () => {
            if (!(options === null || options === void 0 ? void 0 : options.quiet)) {
                console.groupCollapsed('%c[MSW] Mocking enabled.', 'color:orangered;font-weight:bold;');
                console.log('%cDocumentation: %chttps://redd.gitbook.io/msw', 'font-weight:bold', 'font-weight:normal');
                console.log('Found an issue? https://github.com/mswjs/msw/issues');
                console.groupEnd();
            }
            return resolve();
        }, reject);
    });
};

const defaultContext = {
    status,
    set,
    delay,
    fetch,
};

function pipe(...funcs) {
    return funcs.reduce((f, g) => (...args) => f(g(...args)));
}

const defaultResponse = {
    status: 200,
    statusText: 'OK',
    body: null,
    delay: 0,
    once: false,
};
function createResponseComposition(overrides = {}) {
    return (...transformers) => {
        const resolvedResponse = Object.assign({}, defaultResponse, {
            headers: new lib_1$1({
                'x-powered-by': 'msw',
            }),
        }, overrides);
        if (transformers.length > 0) {
            return pipe(...transformers)(resolvedResponse);
        }
        return resolvedResponse;
    };
}
const response = Object.assign(createResponseComposition(), {
    once: createResponseComposition({ once: true }),
});

/**
 * Returns a mocked response for a given request using following request handlers.
 */
const getResponse = (req, handlers) => __awaiter(void 0, void 0, void 0, function* () {
    const [relevantHandler, parsedRequest] = handlers.reduce((found, requestHandler) => {
        // Skip any request handlers lookup if a handler is already found,
        // or the current handler is a one-time handler that's been already used.
        if ((found && found[0]) || requestHandler.shouldSkip) {
            return found;
        }
        // Parse the captured request to get additional information.
        // Make the predicate function accept all the necessary information
        // to decide on the interception.
        const parsedRequest = requestHandler.parse
            ? requestHandler.parse(req)
            : null;
        if (requestHandler.predicate(req, parsedRequest)) {
            return [requestHandler, parsedRequest];
        }
    }, []) || [null, null];
    if (relevantHandler == null) {
        return {
            handler: null,
            response: null,
        };
    }
    const { getPublicRequest, defineContext, resolver } = relevantHandler;
    const publicRequest = getPublicRequest
        ? getPublicRequest(req, parsedRequest)
        : req;
    const context = defineContext ? defineContext(publicRequest) : defaultContext;
    const mockedResponse = yield resolver(publicRequest, response, context);
    // Handle a scenario when a request handler is present,
    // but returns no mocked response (i.e. misses a `return res()` statement).
    if (!mockedResponse) {
        return {
            handler: relevantHandler,
            response: null,
        };
    }
    if (mockedResponse.once) {
        // When responded with a one-time response, match the relevant request handler
        // as skipped, so it cannot affect the captured requests anymore.
        relevantHandler.shouldSkip = true;
    }
    return {
        handler: relevantHandler,
        response: mockedResponse,
        publicRequest,
        parsedRequest,
    };
});

function parseRequestBody(body, headers) {
    var _a;
    if (body) {
        // If the intercepted request's body has a JSON Content-Type
        // parse it into an object, otherwise leave as-is.
        const isJsonBody = (_a = headers === null || headers === void 0 ? void 0 : headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('json');
        return isJsonBody && typeof body !== 'object' ? getJsonBody(body) : body;
    }
    // Return whatever falsey body value is given.
    return body;
}

const handleRequestWith = (context, options) => {
    return (event) => __awaiter(void 0, void 0, void 0, function* () {
        const channel = createBroadcastChannel(event);
        try {
            const message = JSON.parse(event.data, function (key, value) {
                if (key === 'url') {
                    return new URL(value);
                }
                // Serialize headers
                if (key === 'headers') {
                    return new lib_1$1(value);
                }
                // Prevent empty fields from presering an empty value.
                // It's invalid to perform a GET request with { body: "" }
                if (
                // Check if we are parsing deeper in `event.data.payload`,
                // because this custom JSON parser is invoked for each depth level.
                this.method &&
                    isStringEqual(this.method, 'GET') &&
                    key === 'body' &&
                    value === '') {
                    return undefined;
                }
                return value;
            });
            const { type, payload: req } = message;
            // Ignore irrelevant worker message types
            if (type !== 'REQUEST') {
                return null;
            }
            // Parse the request's body based on the "Content-Type" header.
            req.body = parseRequestBody(req.body, req.headers);
            const { response, handler, publicRequest, parsedRequest, } = yield getResponse(req, context.requestHandlers);
            // Handle a scenario when there is no request handler
            // found for a given request.
            if (!handler) {
                return channel.send({ type: 'MOCK_NOT_FOUND' });
            }
            // Handle a scenario when there is a request handler,
            // but it doesn't return any mocked response.
            if (!response) {
                console.warn('[MSW] Expected a mocking resolver function to return a mocked response Object, but got: %s. Original response is going to be used instead.', response);
                return channel.send({ type: 'MOCK_NOT_FOUND' });
            }
            const responseWithSerializedHeaders = Object.assign(Object.assign({}, response), { headers: lib_2(response.headers) });
            if (!options.quiet) {
                setTimeout(() => {
                    handler.log(publicRequest, responseWithSerializedHeaders, handler, parsedRequest);
                }, response.delay);
            }
            channel.send({
                type: 'MOCK_SUCCESS',
                payload: responseWithSerializedHeaders,
            });
        }
        catch (error) {
            channel.send({
                type: 'INTERNAL_ERROR',
                payload: {
                    status: 500,
                    body: JSON.stringify({
                        errorType: error.constructor.name,
                        message: error.message,
                        location: error.stack,
                    }),
                },
            });
        }
    });
};

function requestIntegrityCheck(serviceWorker) {
    return new Promise((resolve, reject) => {
        addMessageListener('INTEGRITY_CHECK_RESPONSE', (message) => {
            const { payload: actualChecksum } = message;
            // Compare the response from the Service Worker and the
            // global variable set by webpack upon build.
            if (actualChecksum !== "3b8ed9e2e9775de6221fe86bf5bbc2ec") {
                return reject(new Error(`Currently active Service Worker (${actualChecksum}) is behind the latest published one (${"3b8ed9e2e9775de6221fe86bf5bbc2ec"}).`));
            }
            resolve(serviceWorker);
        });
        navigator.serviceWorker.addEventListener('messageerror', reject);
        // Signal Service Worker to report back its integrity
        serviceWorker.postMessage('INTEGRITY_CHECK_REQUEST');
    });
}

/**
 * Intercepts and defers any requests on the page
 * until the Service Worker instance is ready.
 */
function deferNetworkRequests(workerReady) {
    // Defer `XMLHttpRequest` until the Service Worker is ready.
    const originalXhrSend = window.XMLHttpRequest.prototype.send;
    window.XMLHttpRequest.prototype.send = function (...args) {
        lib_1(() => workerReady).then(() => {
            window.XMLHttpRequest.prototype.send = originalXhrSend;
            this.send(...args);
        });
    };
    // Defer `fetch` requests until the Service Worker is ready.
    const originalFetch = window.fetch;
    window.fetch = (...args) => __awaiter(this, void 0, void 0, function* () {
        yield lib_1(() => workerReady);
        window.fetch = originalFetch;
        return window.fetch(...args);
    });
}

const DEFAULT_START_OPTIONS = {
    serviceWorker: {
        url: '/mockServiceWorker.js',
        options: null,
    },
    quiet: false,
    waitUntilReady: true,
};
const createStart = (context) => {
    /**
     * Registers and activates the mock Service Worker.
     */
    return function start(options) {
        const resolvedOptions = Object.assign({}, DEFAULT_START_OPTIONS, options);
        const startWorkerInstance = () => __awaiter(this, void 0, void 0, function* () {
            if (!('serviceWorker' in navigator)) {
                console.error(`[MSW] Failed to register a Service Worker: this browser does not support Service Workers (see https://caniuse.com/serviceworkers), or your application is running on an insecure host (consider using HTTPS for custom hostnames).`);
                return null;
            }
            navigator.serviceWorker.addEventListener('message', handleRequestWith(context, resolvedOptions));
            const [, instance] = yield lib_1(() => getWorkerInstance(resolvedOptions.serviceWorker.url, resolvedOptions.serviceWorker.options));
            if (!instance) {
                return null;
            }
            const [worker, registration] = instance;
            if (!worker) {
                return null;
            }
            context.worker = worker;
            context.registration = registration;
            window.addEventListener('beforeunload', () => {
                if (worker.state !== 'redundant') {
                    // Notify the Service Worker that this client has closed.
                    // Internally, it's similar to disabling the mocking, only
                    // client close event has a handler that self-terminates
                    // the Service Worker when there are no open clients.
                    worker.postMessage('CLIENT_CLOSED');
                }
            });
            // Check if the active Service Worker is the latest published one
            const [integrityError] = yield lib_1(() => requestIntegrityCheck(worker));
            if (integrityError) {
                console.error(`\
[MSW] Detected outdated Service Worker: ${integrityError.message}

The mocking is still enabled, but it's highly recommended that you update your Service Worker by running:

$ npx msw init <PUBLIC_DIR>

This is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.
If this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues\
      `);
            }
            // Signal the Service Worker to enable requests interception
            const [activationError] = yield lib_1(() => activateMocking(worker, options));
            if (activationError) {
                console.error('Failed to enable mocking', activationError);
                return null;
            }
            return registration;
        });
        const workerRegistration = startWorkerInstance();
        // Defer any network requests until the Service Worker instance is ready.
        // This prevents a race condition between the Service Worker registration
        // and application's runtime requests (i.e. requests on mount).
        if (resolvedOptions.waitUntilReady) {
            deferNetworkRequests(workerRegistration);
        }
        return workerRegistration;
    };
};

const createStop = (context) => {
    /**
     * Stop the active running instance of the Service Worker.
     */
    return function stop() {
        var _a;
        // Signal the Service Worker to disable mocking for this client.
        // Use this an an explicit way to stop the mocking, while preserving
        // the worker-client relation. Does not affect the worker's lifecycle.
        (_a = context.worker) === null || _a === void 0 ? void 0 : _a.postMessage('MOCK_DEACTIVATE');
    };
};

function use(currentHandlers, ...handlers) {
    currentHandlers.unshift(...handlers);
}
function restoreHandlers(handlers) {
    handlers.forEach((handler) => {
        if ('shouldSkip' in handler) {
            handler.shouldSkip = false;
        }
    });
}
function resetHandlers(initialHandlers, ...nextHandlers) {
    return nextHandlers.length > 0 ? [...nextHandlers] : [...initialHandlers];
}

/**
 * Configures a Service Worker with the given request handler functions.
 */
function setupWorker(...requestHandlers) {
    const context = {
        worker: null,
        registration: null,
        requestHandlers: [...requestHandlers],
    };
    return {
        start: createStart(context),
        stop: createStop(context),
        use(...handlers) {
            use(context.requestHandlers, ...handlers);
        },
        restoreHandlers() {
            restoreHandlers(context.requestHandlers);
        },
        resetHandlers(...nextHandlers) {
            context.requestHandlers = resetHandlers(requestHandlers, ...nextHandlers);
        },
    };
}
/**
 * Composes multiple request handlers into a single mocking schema.
 * @deprecated
 */
function composeMocks(...requestHandlers) {
    console.warn('[MSW] The `composeMocks()` function is deprecated and will be removed in the next release. Please use the `setupWorker()` function instead.');
    return setupWorker(...requestHandlers);
}

export { composeMocks, defaultContext, response, setupWorker };

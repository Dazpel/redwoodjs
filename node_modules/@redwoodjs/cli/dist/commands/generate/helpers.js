"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.intForeignKeysForModel = exports.relationsForModel = exports.createYargsForComponentGeneration = exports.pathName = exports.templateForComponentFile = void 0;

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/filter"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));

var _entries = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/entries"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/for-each"));

var _path = _interopRequireDefault(require("path"));

var _camelcase = _interopRequireDefault(require("camelcase"));

var _pluralize = _interopRequireDefault(require("pluralize"));

var _listr = _interopRequireDefault(require("listr"));

var _pascalcase = _interopRequireDefault(require("pascalcase"));

var _paramCase = require("param-case");

var _terminalLink = _interopRequireDefault(require("terminal-link"));

var _lib = require("../../lib");

var _colors = _interopRequireDefault(require("../../lib/colors"));

var _generate = require("../generate");

/**
 * Reduces boilerplate for generating an output path and content to write to disk
 * for a component.
 */
// TODO: Make this read all the files in a template directory instead of
// manually passing in each file.
const templateForComponentFile = ({
  name,
  suffix = '',
  extension = '.js',
  webPathSection,
  apiPathSection,
  generator,
  templatePath,
  templateVars,
  componentName,
  outputPath
}) => {
  const basePath = webPathSection ? (0, _lib.getPaths)().web[webPathSection] : (0, _lib.getPaths)().api[apiPathSection];
  const outputComponentName = componentName || (0, _pascalcase.default)((0, _paramCase.paramCase)(name)) + suffix;

  const componentOutputPath = outputPath || _path.default.join(basePath, outputComponentName, outputComponentName + extension);

  const content = (0, _lib.generateTemplate)(_path.default.join(generator, 'templates', templatePath), {
    name,
    // Complexity here is for Windows support
    outputPath: `.${_path.default.sep}${_path.default.relative((0, _lib.getPaths)().base, componentOutputPath)}`.replace(/\\/g, '/'),
    ...templateVars
  });
  return [componentOutputPath, content];
};
/**
 * Creates a route path, either returning the existing path if passed, otherwise
 * creates one based on the name
 */


exports.templateForComponentFile = templateForComponentFile;

const pathName = (path, name) => {
  return path !== null && path !== void 0 ? path : `/${(0, _paramCase.paramCase)(name)}`;
};
/**
 * Reduces boilerplate for creating a yargs handler that writes a component to a
 * location.
 */
// TODO: Make this work for all files, not just components.


exports.pathName = pathName;

const createYargsForComponentGeneration = ({
  componentName,
  filesFn,
  builderObj = _generate.yargsDefaults
}) => {
  return {
    command: `${componentName} <name>`,
    description: `Generate a ${componentName} component`,
    builder: yargs => {
      var _context;

      yargs.positional('name', {
        description: `Name of the ${componentName}`,
        type: 'string'
      }).epilogue(`Also see the ${(0, _terminalLink.default)('Redwood CLI Reference', `https://redwoodjs.com/reference/command-line-interface#generate-${componentName}`)}`);
      (0, _forEach.default)(_context = (0, _entries.default)(builderObj)).call(_context, ([option, config]) => {
        yargs.option(option, config);
      });
    },
    handler: async options => {
      const tasks = new _listr.default([{
        title: `Generating ${componentName} files...`,
        task: async () => {
          const f = await filesFn(options);
          return (0, _lib.writeFilesTask)(f, {
            overwriteExisting: options.force
          });
        }
      }], {
        collapse: false,
        exitOnError: true
      });

      try {
        await tasks.run();
      } catch (e) {
        console.log(_colors.default.error(e.message));
      }
    }
  };
}; // Returns all relations to other models


exports.createYargsForComponentGeneration = createYargsForComponentGeneration;

const relationsForModel = model => {
  var _context2, _context3;

  return (0, _map.default)(_context2 = (0, _filter.default)(_context3 = model.fields).call(_context3, f => f.relationName)).call(_context2, field => {
    const relationName = (0, _camelcase.default)(field.type);
    return field.isList ? (0, _pluralize.default)(relationName) : relationName;
  });
}; // Returns only relations that are of datatype Int


exports.relationsForModel = relationsForModel;

const intForeignKeysForModel = model => {
  var _context4, _context5;

  return (0, _map.default)(_context4 = (0, _filter.default)(_context5 = model.fields).call(_context5, f => f.name.match(/Id$/) && f.type === 'Int')).call(_context4, f => f.name);
};

exports.intForeignKeysForModel = intForeignKeysForModel;
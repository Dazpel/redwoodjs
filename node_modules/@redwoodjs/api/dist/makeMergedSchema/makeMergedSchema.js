"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs3/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.makeMergedSchema = void 0;

var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/values"));

var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/includes"));

var _startsWith = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/starts-with"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/filter"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/keys"));

var _reduce = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/reduce"));

var _apolloServerLambda = require("apollo-server-lambda");

var _mergeGraphqlSchemas = require("merge-graphql-schemas");

var _lodash = _interopRequireDefault(require("lodash.merge"));

var _lodash2 = _interopRequireDefault(require("lodash.omitby"));

var rootSchema = _interopRequireWildcard(require("./rootSchema"));

const mapFieldsToService = ({
  fields = {},
  resolvers: unmappedResolvers,
  services
}) => {
  var _context;

  return (0, _reduce.default)(_context = (0, _keys.default)(fields)).call(_context, (resolvers, name) => {
    // Does the function already exist in the resolvers from the schema definition?
    if (resolvers === null || resolvers === void 0 ? void 0 : resolvers[name]) {
      return resolvers;
    } // Does a function exist in the service?


    if (services === null || services === void 0 ? void 0 : services[name]) {
      return { ...resolvers,
        // Map the arguments from GraphQL to an ordinary function a service would
        // expect.
        [name]: (root, args, context, info) => services[name](args, {
          root,
          context,
          info
        })
      };
    }

    return resolvers;
  }, unmappedResolvers);
};
/**
 * This iterates over all the schemas definitions and figures out which resolvers
 * are missing, it then tries to add the missing resolvers from the corresponding
 * service.
 */


const mergeResolversWithServices = ({
  schema,
  resolvers,
  services
}) => {
  var _context2, _context3, _context4, _context5, _context6;

  const mergedServices = (0, _lodash.default)({}, ...(0, _map.default)(_context2 = (0, _keys.default)(services)).call(_context2, name => services[name])); // Get a list of types that have fields.
  // TODO: Figure out if this would interfere with other types: Interface types, etc.`

  const typesWithFields = (0, _filter.default)(_context3 = (0, _map.default)(_context4 = (0, _filter.default)(_context5 = (0, _filter.default)(_context6 = (0, _keys.default)(schema.getTypeMap())).call(_context6, name => !(0, _startsWith.default)(name).call(name, '_'))).call(_context5, name => typeof schema.getType(name).getFields !== 'undefined')).call(_context4, name => {
    return schema.getType(name);
  })).call(_context3, type => type !== undefined && type !== null);
  const mappedResolvers = (0, _reduce.default)(typesWithFields).call(typesWithFields, (acc, type) => {
    var _context7;

    // Services export Query and Mutation field resolvers as named exports,
    // but other GraphQLObjectTypes are exported as an object that are named
    // after the type.
    // Example: export const MyType = { field: () => {} }
    let servicesForType = mergedServices;

    if (!(0, _includes.default)(_context7 = ['Query', 'Mutation']).call(_context7, type.name)) {
      servicesForType = mergedServices === null || mergedServices === void 0 ? void 0 : mergedServices[type.name];
    }

    return { ...acc,
      [type.name]: mapFieldsToService({
        fields: type.getFields(),
        resolvers: resolvers === null || resolvers === void 0 ? void 0 : resolvers[type.name],
        services: servicesForType
      })
    };
  }, {});
  return (0, _lodash2.default)({ ...resolvers,
    ...mappedResolvers
  }, v => typeof v === 'undefined');
};

const mergeResolvers = schemas => {
  var _context8;

  return (0, _lodash2.default)((0, _lodash.default)({}, ...[rootSchema.resolvers, ...(0, _map.default)(_context8 = (0, _values.default)(schemas)).call(_context8, ({
    resolvers
  }) => resolvers)]), v => typeof v === 'undefined');
};
/**
 * Merge GraphQL typeDefs and resolvers into a single schema.
 *
 * @example
 * ```js
 * const schemas = importAll('api', 'graphql')
 * const services = importAll('api', 'services')
 *
 * const schema = makeMergedSchema({
 *  schema,
 *  services: makeServices({ services }),
 * })
 * ```
 */


const makeMergedSchema = ({
  schemas,
  services,
  schemaDirectives
}) => {
  var _context9;

  const typeDefs = (0, _mergeGraphqlSchemas.mergeTypes)([rootSchema.schema, ...(0, _map.default)(_context9 = (0, _values.default)(schemas)).call(_context9, ({
    schema
  }) => schema)], {
    all: true
  });
  const schema = (0, _apolloServerLambda.makeExecutableSchema)({
    typeDefs,
    schemaDirectives
  });
  const resolvers = mergeResolversWithServices({
    schema,
    resolvers: mergeResolvers(schemas),
    services
  });
  (0, _apolloServerLambda.addResolveFunctionsToSchema)({
    schema,
    resolvers
  });
  return schema;
};

exports.makeMergedSchema = makeMergedSchema;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tYWtlTWVyZ2VkU2NoZW1hL21ha2VNZXJnZWRTY2hlbWEudHMiXSwibmFtZXMiOlsibWFwRmllbGRzVG9TZXJ2aWNlIiwiZmllbGRzIiwicmVzb2x2ZXJzIiwidW5tYXBwZWRSZXNvbHZlcnMiLCJzZXJ2aWNlcyIsIm5hbWUiLCJyb290IiwiYXJncyIsImNvbnRleHQiLCJpbmZvIiwibWVyZ2VSZXNvbHZlcnNXaXRoU2VydmljZXMiLCJzY2hlbWEiLCJtZXJnZWRTZXJ2aWNlcyIsInR5cGVzV2l0aEZpZWxkcyIsImdldFR5cGVNYXAiLCJnZXRUeXBlIiwiZ2V0RmllbGRzIiwidHlwZSIsInVuZGVmaW5lZCIsIm1hcHBlZFJlc29sdmVycyIsImFjYyIsInNlcnZpY2VzRm9yVHlwZSIsInYiLCJtZXJnZVJlc29sdmVycyIsInNjaGVtYXMiLCJyb290U2NoZW1hIiwibWFrZU1lcmdlZFNjaGVtYSIsInNjaGVtYURpcmVjdGl2ZXMiLCJ0eXBlRGVmcyIsImFsbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQU1BOztBQUNBOztBQUNBOztBQUlBOztBQUVBLE1BQU1BLGtCQUFrQixHQUFHLENBQUM7QUFDMUJDLEVBQUFBLE1BQU0sR0FBRyxFQURpQjtBQUUxQkMsRUFBQUEsU0FBUyxFQUFFQyxpQkFGZTtBQUcxQkMsRUFBQUE7QUFIMEIsQ0FBRDtBQUFBOztBQUFBLFNBU3pCLG1EQUFZSCxNQUFaLGtCQUEyQixDQUFDQyxTQUFELEVBQVlHLElBQVosS0FBcUI7QUFDOUM7QUFDQSxRQUFJSCxTQUFKLGFBQUlBLFNBQUosdUJBQUlBLFNBQVMsQ0FBR0csSUFBSCxDQUFiLEVBQXVCO0FBQ3JCLGFBQU9ILFNBQVA7QUFDRCxLQUo2QyxDQU05Qzs7O0FBQ0EsUUFBSUUsUUFBSixhQUFJQSxRQUFKLHVCQUFJQSxRQUFRLENBQUdDLElBQUgsQ0FBWixFQUFzQjtBQUNwQixhQUFPLEVBQ0wsR0FBR0gsU0FERTtB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QUEsT0FEK0I7QUFFL0JwQixFQUFBQSxRQUYrQjtBQUcvQnVCLEVBQUFBO0FBSCtCLENBQUQsS0FRMUI7QUFBQTs7QUFDSixRQUFNQyxRQUFRLEdBQUcscUNBQ2YsQ0FBQ0gsVUFBVSxDQUFDZCxNQUFaLEVBQW9CLEdBQUcsbURBQWNhLE9BQWQsbUJBQTJCLENBQUM7QUFBRWIsSUFBQUE7QUFBRixHQUFELEtBQWdCQSxNQUEzQyxDQUF2QixDQURlLEVBRWY7QUFBRWtCLElBQUFBLEdBQUcsRUFBRTtBQUFQLEdBRmUsQ0FBakI7QUFLQSxRQUFNbEIsTUFBTSxHQUFHLDhDQUFxQjtBQUNsQ2lCLElBQUFBLFFBRGtDO0FBRWxDRCxJQUFBQTtBQUZrQyxHQUFyQixDQUFmO0FBS0EsUUFBTXpCLFNBQXFCLEdBQUdRLDBCQUEwQixDQUFDO0FBQ3ZEQyxJQUFBQSxNQUR1RDtBQUV2RFQsSUFBQUEsU0FBUyxFQUFFcUIsY0FBYyxDQUFDQyxPQUFELENBRjhCO0FBR3ZEcEIsSUFBQUE7QUFIdUQsR0FBRCxDQUF4RDtBQUtBLHVEQUE0QjtBQUFFTyxJQUFBQSxNQUFGO0FBQVVULElBQUFBO0FBQVYsR0FBNUI7QUFFQSxTQUFPUyxNQUFQO0FBQ0QsQ0EzQk0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBhZGRSZXNvbHZlRnVuY3Rpb25zVG9TY2hlbWEsXG4gIG1ha2VFeGVjdXRhYmxlU2NoZW1hLFxuICBJUmVzb2x2ZXJzLFxuICBJRXhlY3V0YWJsZVNjaGVtYURlZmluaXRpb24sXG59IGZyb20gJ2Fwb2xsby1zZXJ2ZXItbGFtYmRhJ1xuaW1wb3J0IHsgbWVyZ2VUeXBlcyB9IGZyb20gJ21lcmdlLWdyYXBocWwtc2NoZW1hcydcbmltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gubWVyZ2UnXG5pbXBvcnQgb21pdEJ5IGZyb20gJ2xvZGFzaC5vbWl0YnknXG5pbXBvcnQgeyBHcmFwaFFMU2NoZW1hLCBHcmFwaFFMRmllbGRNYXAgfSBmcm9tICdncmFwaHFsJ1xuaW1wb3J0IHsgU2VydmljZXMsIEdyYXBoUUxUeXBlV2l0aEZpZWxkcyB9IGZyb20gJ3NyYy90eXBlcydcblxuaW1wb3J0ICogYXMgcm9vdFNjaGVtYSBmcm9tICcuL3Jvb3RTY2hlbWEnXG5cbmNvbnN0IG1hcEZpZWxkc1RvU2VydmljZSA9ICh7XG4gIGZpZWxkcyA9IHt9LFxuICByZXNvbHZlcnM6IHVubWFwcGVkUmVzb2x2ZXJzLFxuICBzZXJ2aWNlcyxcbn06IHtcbiAgZmllbGRzOiBHcmFwaFFMRmllbGRNYXA8YW55LCBhbnk+XG4gIHJlc29sdmVyczogeyBba2V5OiBzdHJpbmddOiBGdW5jdGlvbiB9XG4gIHNlcnZpY2VzOiBTZXJ2aWNlc1xufSkgPT5cbiAgT2JqZWN0LmtleXMoZmllbGRzKS5yZWR1Y2UoKHJlc29sdmVycywgbmFtZSkgPT4ge1xuICAgIC8vIERvZXMgdGhlIGZ1bmN0aW9uIGFscmVhZHkgZXhpc3QgaW4gdGhlIHJlc29sdmVycyBmcm9tIHRoZSBzY2hlbWEgZGVmaW5pdGlvbj9cbiAgICBpZiAocmVzb2x2ZXJzPy5bbmFtZV0pIHtcbiAgICAgIHJldHVybiByZXNvbHZlcnNcbiAgICB9XG5cbiAgICAvLyBEb2VzIGEgZnVuY3Rpb24gZXhpc3QgaW4gdGhlIHNlcnZpY2U/XG4gICAgaWYgKHNlcnZpY2VzPy5bbmFtZV0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJlc29sdmVycyxcbiAgICAgICAgLy8gTWFwIHRoZSBhcmd1bWVudHMgZnJvbSBHcmFwaFFMIHRvIGFuIG9yZGluYXJ5IGZ1bmN0aW9uIGEgc2VydmljZSB3b3VsZFxuICAgICAgICAvLyBleHBlY3QuXG4gICAgICAgIFtuYW1lXTogKFxuICAgICAgICAgIHJvb3Q6IHVua25vd24sXG4gICAgICAgICAgYXJnczogdW5rbm93bixcbiAgICAgICAgICBjb250ZXh0OiB1bmtub3duLFxuICAgICAgICAgIGluZm86IHVua25vd25cbiAgICAgICAgKSA9PiBzZXJ2aWNlc1tuYW1lXShhcmdzLCB7IHJvb3QsIGNvbnRleHQsIGluZm8gfSksXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc29sdmVyc1xuICB9LCB1bm1hcHBlZFJlc29sdmVycylcblxuLyoqXG4gKiBUaGlzIGl0ZXJhdGVzIG92ZXIgYWxsIHRoZSBzY2hlbWFzIGRlZmluaXRpb25zIGFuZCBmaWd1cmVzIG91dCB3aGljaCByZXNvbHZlcnNcbiAqIGFyZSBtaXNzaW5nLCBpdCB0aGVuIHRyaWVzIHRvIGFkZCB0aGUgbWlzc2luZyByZXNvbHZlcnMgZnJvbSB0aGUgY29ycmVzcG9uZGluZ1xuICogc2VydmljZS5cbiAqL1xuY29uc3QgbWVyZ2VSZXNvbHZlcnNXaXRoU2VydmljZXMgPSAoe1xuICBzY2hlbWEsXG4gIHJlc29sdmVycyxcbiAgc2VydmljZXMsXG59OiB7XG4gIHNjaGVtYTogR3JhcGhRTFNjaGVtYVxuICByZXNvbHZlcnM6IHsgW2tleTogc3RyaW5nXTogYW55IH1cbiAgc2VydmljZXM6IFNlcnZpY2VzXG59KTogSVJlc29sdmVycyA9PiB7XG4gIGNvbnN0IG1lcmdlZFNlcnZpY2VzID0gbWVyZ2UoXG4gICAge30sXG4gICAgLi4uT2JqZWN0LmtleXMoc2VydmljZXMpLm1hcCgobmFtZSkgPT4gc2VydmljZXNbbmFtZV0pXG4gIClcblxuICAvLyBHZXQgYSBsaXN0IG9mIHR5cGVzIHRoYXQgaGF2ZSBmaWVsZHMuXG4gIC8vIFRPRE86IEZpZ3VyZSBvdXQgaWYgdGhpcyB3b3VsZCBpbnRlcmZlcmUgd2l0aCBvdGhlciB0eXBlczogSW50ZXJmYWNlIHR5cGVzLCBldGMuYFxuICBjb25zdCB0eXBlc1dpdGhGaWVsZHMgPSBPYmplY3Qua2V5cyhzY2hlbWEuZ2V0VHlwZU1hcCgpKVxuICAgIC5maWx0ZXIoKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ18nKSlcbiAgICAuZmlsdGVyKFxuICAgICAgKG5hbWUpID0+XG4gICAgICAgIHR5cGVvZiAoc2NoZW1hLmdldFR5cGUobmFtZSkgYXMgR3JhcGhRTFR5cGVXaXRoRmllbGRzKS5nZXRGaWVsZHMgIT09XG4gICAgICAgICd1bmRlZmluZWQnXG4gICAgKVxuICAgIC5tYXAoKG5hbWUpID0+IHtcbiAgICAgIHJldHVybiBzY2hlbWEuZ2V0VHlwZShuYW1lKVxuICAgIH0pXG4gICAgLmZpbHRlcihcbiAgICAgICh0eXBlKTogdHlwZSBpcyBHcmFwaFFMVHlwZVdpdGhGaWVsZHMgPT5cbiAgICAgICAgdHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUgIT09IG51bGxcbiAgICApXG5cbiAgY29uc3QgbWFwcGVkUmVzb2x2ZXJzID0gdHlwZXNXaXRoRmllbGRzLnJlZHVjZSgoYWNjLCB0eXBlKSA9PiB7XG4gICAgLy8gU2VydmljZXMgZXhwb3J0IFF1ZXJ5IGFuZCBNdXRhdGlvbiBmaWVsZCByZXNvbHZlcnMgYXMgbmFtZWQgZXhwb3J0cyxcbiAgICAvLyBidXQgb3RoZXIgR3JhcGhRTE9iamVjdFR5cGVzIGFyZSBleHBvcnRlZCBhcyBhbiBvYmplY3QgdGhhdCBhcmUgbmFtZWRcbiAgICAvLyBhZnRlciB0aGUgdHlwZS5cbiAgICAvLyBFeGFtcGxlOiBleHBvcnQgY29uc3QgTXlUeXBlID0geyBmaWVsZDogKCkgPT4ge30gfVxuICAgIGxldCBzZXJ2aWNlc0ZvclR5cGUgPSBtZXJnZWRTZXJ2aWNlc1xuICAgIGlmICghWydRdWVyeScsICdNdXRhdGlvbiddLmluY2x1ZGVzKHR5cGUubmFtZSkpIHtcbiAgICAgIHNlcnZpY2VzRm9yVHlwZSA9IG1lcmdlZFNlcnZpY2VzPy5bdHlwZS5uYW1lXVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5hY2MsXG4gICAgICBbdHlwZS5uYW1lXTogbWFwRmllbGRzVG9TZXJ2aWNlKHtcbiAgICAgICAgZmllbGRzOiB0eXBlLmdldEZpZWxkcygpLFxuICAgICAgICByZXNvbHZlcnM6IHJlc29sdmVycz8uW3R5cGUubmFtZV0sXG4gICAgICAgIHNlcnZpY2VzOiBzZXJ2aWNlc0ZvclR5cGUsXG4gICAgICB9KSxcbiAgICB9XG4gIH0sIHt9KVxuXG4gIHJldHVybiBvbWl0QnkoXG4gICAge1xuICAgICAgLi4ucmVzb2x2ZXJzLFxuICAgICAgLi4ubWFwcGVkUmVzb2x2ZXJzLFxuICAgIH0sXG4gICAgKHYpID0+IHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJ1xuICApXG59XG5cbmNvbnN0IG1lcmdlUmVzb2x2ZXJzID0gKHNjaGVtYXM6IHtcbiAgW2tleTogc3RyaW5nXTogeyBzY2hlbWE6IG9iamVjdDsgcmVzb2x2ZXJzOiBvYmplY3QgfVxufSkgPT5cbiAgb21pdEJ5KFxuICAgIG1lcmdlKFxuICAgICAge30sXG4gICAgICAuLi5bXG4gICAgICAgIHJvb3RTY2hlbWEucmVzb2x2ZXJzLFxuICAgICAgICAuLi5PYmplY3QudmFsdWVzKHNjaGVtYXMpLm1hcCgoeyByZXNvbHZlcnMgfSkgPT4gcmVzb2x2ZXJzKSxcbiAgICAgIF1cbiAgICApLFxuICAgICh2KSA9PiB0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCdcbiAgKVxuXG4vKipcbiAqIE1lcmdlIEdyYXBoUUwgdHlwZURlZnMgYW5kIHJlc29sdmVycyBpbnRvIGEgc2luZ2xlIHNjaGVtYS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNvbnN0IHNjaGVtYXMgPSBpbXBvcnRBbGwoJ2FwaScsICdncmFwaHFsJylcbiAqIGNvbnN0IHNlcnZpY2VzID0gaW1wb3J0QWxsKCdhcGknLCAnc2VydmljZXMnKVxuICpcbiAqIGNvbnN0IHNjaGVtYSA9IG1ha2VNZXJnZWRTY2hlbWEoe1xuICogIHNjaGVtYSxcbiAqICBzZXJ2aWNlczogbWFrZVNlcnZpY2VzKHsgc2VydmljZXMgfSksXG4gKiB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBtYWtlTWVyZ2VkU2NoZW1hID0gKHtcbiAgc2NoZW1hcyxcbiAgc2VydmljZXMsXG4gIHNjaGVtYURpcmVjdGl2ZXMsXG59OiB7XG4gIHNjaGVtYXM6IHsgW2tleTogc3RyaW5nXTogeyBzY2hlbWE6IG9iamVjdDsgcmVzb2x2ZXJzOiBvYmplY3QgfSB9XG4gIHNlcnZpY2VzOiBTZXJ2aWNlc1xuICBzY2hlbWFEaXJlY3RpdmVzPzogSUV4ZWN1dGFibGVTY2hlbWFEZWZpbml0aW9uWydzY2hlbWFEaXJlY3RpdmVzJ11cbn0pID0+IHtcbiAgY29uc3QgdHlwZURlZnMgPSBtZXJnZVR5cGVzKFxuICAgIFtyb290U2NoZW1hLnNjaGVtYSwgLi4uT2JqZWN0LnZhbHVlcyhzY2hlbWFzKS5tYXAoKHsgc2NoZW1hIH0pID0+IHNjaGVtYSldLFxuICAgIHsgYWxsOiB0cnVlIH1cbiAgKVxuXG4gIGNvbnN0IHNjaGVtYSA9IG1ha2VFeGVjdXRhYmxlU2NoZW1hKHtcbiAgICB0eXBlRGVmcyxcbiAgICBzY2hlbWFEaXJlY3RpdmVzLFxuICB9KVxuXG4gIGNvbnN0IHJlc29sdmVyczogSVJlc29sdmVycyA9IG1lcmdlUmVzb2x2ZXJzV2l0aFNlcnZpY2VzKHtcbiAgICBzY2hlbWEsXG4gICAgcmVzb2x2ZXJzOiBtZXJnZVJlc29sdmVycyhzY2hlbWFzKSxcbiAgICBzZXJ2aWNlcyxcbiAgfSlcbiAgYWRkUmVzb2x2ZUZ1bmN0aW9uc1RvU2NoZW1hKHsgc2NoZW1hLCByZXNvbHZlcnMgfSlcblxuICByZXR1cm4gc2NoZW1hXG59XG4iXX0=